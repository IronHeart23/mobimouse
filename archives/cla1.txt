// _layout.tsximport { Stack } from 'expo-router';export default function Layout() {  return (    <Stack      screenOptions={{        headerStyle: {          backgroundColor: '#1a1a1a', // Dark header color        },        headerTintColor: '#fff',        headerTitleStyle: {          fontWeight: 'bold',        },      }}    />  );}//touchpad.tsximport { useRouter, useLocalSearchParams } from 'expo-router';  // Instead of using navigation propimport React, { useState, useEffect, useRef } from 'react';import { View, PanResponder, Button, StyleSheet } from 'react-native';import axios from 'axios';const App = () => {    const router = useRouter(); // Use the router hook    //const [serverIp, setServerIp] = useState('192.168.1.107'); // Replace with your computer's IP    const { serverIp } = useLocalSearchParams<{ serverIp: string }>();    const [screenSize, setScreenSize] = useState({ width: 0, height: 0 });    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 }); // Tracks current mouse position    useEffect(() => {        const fetchInitialData = async () => {            try {                const screenResponse = await axios.get(`http://${serverIp}:3000/screen`);                setScreenSize(screenResponse.data);                const mouseResponse = await axios.get(`http://${serverIp}:3000/mouse/position`);                setMousePosition(mouseResponse.data);            } catch (error) {                console.error('Error fetching initial data:', error);            }        };        fetchInitialData();    }, [serverIp]);    const [isHolding, setIsHolding] = useState(false);    const lastTapTime = useRef(0);    const TAP_INTERVAL = 300; // ms between taps to count as double-tap        const [isDragging, setIsDragging] = useState(false);    const lastMouseCheck = useRef(Date.now());    const IDLE_CHECK_INTERVAL = 2000; // Check mouse position after 2s idleuseEffect(() => {    const checkMousePosition = async () => {        if (Date.now() - lastMouseCheck.current > IDLE_CHECK_INTERVAL) {            try {                const mouseResponse = await axios.get(`http://${serverIp}:3000/mouse/position`);                setMousePosition(mouseResponse.data);                lastMouseCheck.current = Date.now();            } catch (error) {                console.error('Error fetching mouse position:', error);            }        }    };    const interval = setInterval(checkMousePosition, IDLE_CHECK_INTERVAL);    return () => clearInterval(interval);}, [serverIp]);// Add this state for tracking touchesconst [touchCount, setTouchCount] = useState(0);const [lastClickTime, setLastClickTime] = useState(0);const CLICK_DELAY = 200; // Delay to check for potential double tapconst [isLeftClickHeld, setIsLeftClickHeld] = useState(false);const MOVEMENT_THRESHOLD = 1; // Increased threshold for movement detectionconst panResponder = PanResponder.create({    onStartShouldSetPanResponder: () => true,    onMoveShouldSetPanResponder: () => true,        onPanResponderGrant: (evt) => {        const touches = evt.nativeEvent.touches.length;        setTouchCount(touches);                const currentTime = Date.now();        pressStartTime.current = currentTime;        hasMoved.current = false;                if (touches === 2) {            setIsLeftClickHeld(true);            axios.post(`http://${serverIp}:3000/mouse/hold`, { button: 'left', action: 'down' });        } else if (touches === 1) {            if (currentTime - lastTapTime.current < TAP_INTERVAL) {                setLastClickTime(0);                axios.post(`http://${serverIp}:3000/mouse/hold`, { button: 'left', action: 'down' });                setIsDragging(true);            }            lastTapTime.current = currentTime;        }    },        onPanResponderMove: (event, gesture) => {        const touches = event.nativeEvent.touches.length;                // Increase threshold for movement detection        if (Math.abs(gesture.dx) > MOVEMENT_THRESHOLD || Math.abs(gesture.dy) > MOVEMENT_THRESHOLD) {            hasMoved.current = true;        }                const newX = Math.min(Math.max(0, mousePosition.x + (gesture.dx / 300) * screenSize.width), screenSize.width);        const newY = Math.min(Math.max(0, mousePosition.y + (gesture.dy / 300) * screenSize.height), screenSize.height);        setMousePosition({ x: newX, y: newY });        axios.post(`http://${serverIp}:3000/mouse/move`, { x: newX, y: newY });    },        onPanResponderRelease: () => {        const pressDuration = Date.now() - pressStartTime.current;        const currentTime = Date.now();                if (isLeftClickHeld) {            setIsLeftClickHeld(false);            axios.post(`http://${serverIp}:3000/mouse/hold`, { button: 'left', action: 'up' });        }                // Only trigger clicks if there was minimal movement        if (touchCount === 1) {            if (isDragging) {                axios.post(`http://${serverIp}:3000/mouse/hold`, { button: 'left', action: 'up' });                setIsDragging(false);            } else if (!hasMoved.current) {  // This check is now more strict due to higher threshold                if (pressDuration < 500) {                    setLastClickTime(currentTime);                    setTimeout(() => {                        if (Date.now() - lastClickTime >= TAP_INTERVAL) {                            handleClick('left');                        }                    }, CLICK_DELAY);                } else {                    handleClick('right');                }            }        }                setTouchCount(0);    },});    const pressStartTime = useRef(0);    const hasMoved = useRef(false);    const handleClick = (buttonType: 'left' | 'right') => {        axios.post(`http://${serverIp}:3000/mouse/click`, { button: buttonType });    };    return (        <View style={styles.container}>            <View style={styles.touchpad} {...panResponder.panHandlers} />            <View style={styles.buttonContainer}>                <Button title="Left Click" onPress={() => handleClick('left')} />                <Button title="Right Click" onPress={() => handleClick('right')} />            </View>        </View>    );};const styles = StyleSheet.create({    container: { flex: 1, justifyContent: 'center', alignItems: 'center' },    touchpad: {        width: 400,        height: 700,        backgroundColor: '#ddd',        borderRadius: 10,        marginBottom: 20,    },    buttonContainer: {        flexDirection: 'row',        gap: 10,    }});export default App;// app/index.tsximport React, { useState, useEffect, useRef } from 'react';import { View, Text, Pressable, StyleSheet, ScrollView, ActivityIndicator } from 'react-native';import { Link } from 'expo-router';import { MaterialIcons } from '@expo/vector-icons';import NetInfo from '@react-native-community/netinfo';import dgram from 'react-native-udp';import axios from 'axios';interface Device {  id: string;  name: string;  ip: string;  port: number;}export default function Home() {  const [availableDevices, setAvailableDevices] = useState<Device[]>([]);  const [isScanning, setIsScanning] = useState(false);  const [error, setError] = useState<string | null>(null);  const wsRef = useRef<WebSocket | null>(null);  const devicesMap = useRef<Map<string, Device>>(new Map());  const scanTimeout = useRef<NodeJS.Timeout>();  const connectToNetwork = async () => {    setIsScanning(true);    setError(null);    devicesMap.current.clear();    setAvailableDevices([]);    try {      // Check if we're on WiFi      const netInfo = await NetInfo.fetch();      if (netInfo.type !== 'wifi') {        throw new Error('Please connect to a WiFi network');      }      // Close existing WebSocket if any      if (wsRef.current) {        wsRef.current.close();      }      // Try common IP ranges      const baseIps = [        '192.168.1',        '192.168.0',        '10.0.0',        '10.0.1',        'http://192.168.1.107:3000/screen'      ];      for (const baseIp of baseIps) {        for (let i = 1; i <= 5; i++) {  // Only try first 5 IPs for quick response          const ip = `${baseIp}.${i}`;          try {            const ws = new WebSocket(`ws://${ip}:3001`);                        ws.onopen = () => {              console.log(`Connected to ${ip}`);            };            ws.onmessage = (event) => {              try {                const device = JSON.parse(event.data);                const deviceId = `${device.ip}:${device.port}`;                                if (!devicesMap.current.has(deviceId)) {                  devicesMap.current.set(deviceId, {                    id: deviceId,                    name: device.name,                    ip: device.ip,                    port: device.port                  });                                    setAvailableDevices(Array.from(devicesMap.current.values()));                }              } catch (e) {                console.error('Error parsing device data:', e);              }            };            ws.onerror = () => {              ws.close();            };          } catch (e) {            console.log(`Failed to connect to ${ip}`);          }        }      }      // Stop scanning after 5 seconds      scanTimeout.current = setTimeout(() => {        setIsScanning(false);      }, 5000);    } catch (err) {      setError(err instanceof Error ? err.message : 'Failed to scan for devices');      setIsScanning(false);    }  };  useEffect(() => {    connectToNetwork();    return () => {      if (wsRef.current) {        wsRef.current.close();      }      if (scanTimeout.current) {        clearTimeout(scanTimeout.current);      }    };  }, []);  return (    <View style={styles.container}>      <Text style={styles.title}>MobiMouse Connect</Text>            <Text style={styles.descriptionText}>        Other devices running MobiMouse server in your same network will appear here.      </Text>      <Pressable         style={styles.scanButton}         onPress={connectToNetwork}        disabled={isScanning}      >        <Text style={styles.scanButtonText}>          {isScanning ? 'Scanning...' : 'Scan for Devices'}        </Text>      </Pressable>      {error && (        <Text style={styles.errorText}>{error}</Text>      )}      <Text style={styles.sectionTitle}>Available devices</Text>      <ScrollView style={styles.deviceList}>        {isScanning ? (          <ActivityIndicator size="large" color="#4CAF50" />        ) : availableDevices.length > 0 ? (          availableDevices.map((device) => (            <Link               key={device.id}               href={{                pathname: "/touchpad",                params: { serverIp: device.ip }              }}               asChild            >              <Pressable style={styles.deviceItem}>                <MaterialIcons name="computer" size={24} color="#fff" style={styles.deviceIcon} />                <View>                  <Text style={styles.deviceName}>{device.name}</Text>                  <Text style={styles.deviceIp}>{device.ip}</Text>                </View>              </Pressable>            </Link>          ))        ) : (          <Text style={styles.noDevicesText}>No devices found</Text>        )}      </ScrollView>    </View>  );}const styles = StyleSheet.create({  container: {    flex: 1,    backgroundColor: '#1a1a1a',    padding: 20,  },  title: {    fontSize: 34,    fontWeight: 'bold',    color: '#ffffff',    marginBottom: 20,  },  descriptionText: {    fontSize: 16,    color: '#cccccc',    marginBottom: 40,    lineHeight: 24,  },  sectionTitle: {    fontSize: 24,    fontWeight: 'bold',    color: '#ffffff',    marginBottom: 15,  },  deviceList: {    flex: 1,  },  deviceItem: {    flexDirection: 'row',    alignItems: 'center',    padding: 16,    backgroundColor: '#2a2a2a',    borderRadius: 8,    marginBottom: 10,  },  deviceIcon: {    marginRight: 15,  },  deviceName: {    fontSize: 18,    color: '#ffffff',  },  scanButton: {    backgroundColor: '#4CAF50',    padding: 12,    borderRadius: 8,    marginBottom: 20,  },  scanButtonText: {    color: '#fff',    fontSize: 16,    fontWeight: 'bold',    textAlign: 'center',  },  errorText: {    color: '#ff4444',    fontSize: 14,    marginBottom: 20,  },  deviceIp: {    fontSize: 14,    color: '#999999',  },  noDevicesText: {    color: '#999999',    fontSize: 16,    textAlign: 'center',    marginTop: 20,  }});// server.jsconst express = require('express');const robot = require('robotjs');const cors = require('cors');const WebSocket = require('ws');const os = require('os');const app = express();const port = 3000;const wsPort = 3001;// Function to get local IP addressfunction getLocalIP() {    const interfaces = os.networkInterfaces();    for (const name of Object.keys(interfaces)) {        for (const interface of interfaces[name]) {            if (interface.family === 'IPv4' && !interface.internal) {                return interface.address;            }        }    }    return '127.0.0.1';}const ip = getLocalIP();console.log('Server IP:', ip);console.log('Server hostname:', os.hostname());// Create WebSocket server for discoveryconst wss = new WebSocket.Server({ port: wsPort });// Handle WebSocket connectionswss.on('connection', (ws) => {    console.log('Client connected');        // Send server info immediately upon connection    const serverInfo = JSON.stringify({        name: os.hostname(),        ip: ip,        port: port    });    ws.send(serverInfo);    ws.on('close', () => {        console.log('Client disconnected');    });});  setInterval(() => {    const serverInfo = JSON.stringify({      name: os.hostname(),      ip: getLocalIP(),      port: port    });        wss.clients.forEach(client => {      if (client.readyState === WebSocket.OPEN) {        client.send(serverInfo);      }    });  }, 1000);app.use(cors());app.use(express.json());// Endpoint to move the mouseapp.post('/mouse/move', (req, res) => {    const { x, y } = req.body;    robot.moveMouse(x, y);    res.send('Mouse moved!');});// Endpoint to simulate mouse clickapp.post('/mouse/click', (req, res) => {    const { button = 'left' } = req.body; // Default to left button    robot.mouseClick(button);    res.send(`Mouse ${button} click executed!`);});// Endpoint to get screen size (useful for scaling coordinates)app.get('/screen', (req, res) => {    const screenSize = robot.getScreenSize();    res.json(screenSize);});app.listen(port, () => {    console.log(`Server running at http://localhost:${port}`);});// Endpoint to get current mouse positionapp.get('/mouse/position', (req, res) => {    const mousePos = robot.getMousePos();    res.json(mousePos);});const handleClick = (buttonType) => {    axios.post(`http://${serverIp}:3000/mouse/click`, { button: buttonType });};app.post('/mouse/hold', (req, res) => {    const { button, action } = req.body;    if (action === 'down') {        robot.mouseToggle('down', button);    } else {        robot.mouseToggle('up', button);    }    res.send(`Mouse ${button} ${action}`);});app.post('/scroll', (req, res) => {    const { amount } = req.body;        // Adjust scroll sensitivity    const scrollAmount = Math.round(amount / 3); // Adjust divisor for sensitivity        try {        // Vertical scroll        robot.scrollMouse(0, scrollAmount);        res.send('Scrolled successfully');    } catch (error) {        console.error('Scroll error:', error);        res.status(500).send('Scroll failed');    }});// In your server.jsapp.get('/discover', (req, res) => {    res.json({      name: require('os').hostname(),      ip: require('ip').address(),      // Add any other relevant device info    });  });console.log(`Server running at http://localhost:${port}`);console.log(`WebSocket server running on port ${wsPort}`);JSON files//package.json{  "name": "mobimouse",  "main": "expo-router/entry",  "version": "1.0.0",  "scripts": {    "start": "expo start",    "reset-project": "node ./scripts/reset-project.js",    "android": "expo start --android",    "ios": "expo start --ios",    "web": "expo start --web",    "test": "jest --watchAll",    "lint": "expo lint"  },  "jest": {    "preset": "jest-expo"  },  "dependencies": {    "@expo/vector-icons": "^14.0.4",    "@react-native-community/netinfo": "^11.4.1",    "@react-navigation/bottom-tabs": "^7.2.0",    "@react-navigation/native": "^7.0.14",    "@react-navigation/native-stack": "^7.2.0",    "axios": "^1.7.9",    "cors": "^2.8.5",    "expo": "~52.0.23",    "expo-blur": "~14.0.1",    "expo-constants": "~17.0.3",    "expo-font": "~13.0.2",    "expo-haptics": "~14.0.0",    "expo-linking": "~7.0.3",    "expo-network": "^7.0.5",    "expo-router": "~4.0.15",    "expo-splash-screen": "~0.29.18",    "expo-status-bar": "~2.0.0",    "expo-symbols": "~0.2.0",    "expo-system-ui": "~4.0.6",    "expo-web-browser": "~14.0.1",    "express": "^4.21.2",    "react": "18.3.1",    "react-dom": "18.3.1",    "react-native": "0.76.5",    "react-native-ble-manager": "^12.1.2",    "react-native-gesture-handler": "~2.20.2",    "react-native-reanimated": "~3.16.1",    "react-native-safe-area-context": "4.12.0",    "react-native-screens": "~4.4.0",    "react-native-udp": "^4.1.7",    "react-native-web": "~0.19.13",    "react-native-webview": "13.12.5",    "robotjs": "^0.6.0",    "ws": "^8.18.0"  },  "devDependencies": {    "@babel/core": "^7.25.2",    "@types/jest": "^29.5.12",    "@types/react": "~18.3.12",    "@types/react-test-renderer": "^18.3.0",    "jest": "^29.2.1",    "jest-expo": "~52.0.2",    "react-test-renderer": "18.3.1",    "typescript": "^5.3.3"  },  "private": true}//app.json{  "expo": {    "name": "mobimouse",    "slug": "mobimouse",    "version": "1.0.0",    "orientation": "portrait",    "icon": "./assets/images/icon.png",    "scheme": "myapp",    "userInterfaceStyle": "automatic",    "newArchEnabled": true,    "ios": {      "supportsTablet": true    },    "android": {      "adaptiveIcon": {        "foregroundImage": "./assets/images/adaptive-icon.png",        "backgroundColor": "#ffffff"      }    },    "web": {      "bundler": "metro",      "output": "static",      "favicon": "./assets/images/favicon.png"    },    "plugins": [      "expo-router",      [        "expo-splash-screen",        {          "image": "./assets/images/splash-icon.png",          "imageWidth": 200,          "resizeMode": "contain",          "backgroundColor": "#ffffff"        }      ]    ],    "experiments": {      "typedRoutes": true    }  }}