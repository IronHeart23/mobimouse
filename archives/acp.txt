// _layout.tsximport { Stack } from 'expo-router';export default function Layout() {  return (    <Stack      screenOptions={{        headerStyle: {          backgroundColor: '#1a1a1a', // Dark header color        },        headerTintColor: '#fff',        headerTitleStyle: {          fontWeight: 'bold',        },      }}    />  );}//index.tsximport React from 'react';import { View, Text, Pressable, StyleSheet, ScrollView, ActivityIndicator } from 'react-native';import { Link } from 'expo-router';import { MaterialIcons } from '@expo/vector-icons';import useDeviceScanning from './hooks/useDeviceScanning';export default function Home() {  const { availableDevices, isScanning, error, scanNetwork } = useDeviceScanning();  return (    <View style={styles.container}>      <Text style={styles.title}>MobiMouse Connect</Text>            <Text style={styles.descriptionText}>        Other devices running MobiMouse server in your same network will appear here.      </Text>      <Pressable         style={styles.scanButton}        onPress={scanNetwork}        disabled={isScanning}      >        <Text style={styles.scanButtonText}>          {isScanning ? 'Scanning...' : 'Scan for Devices'}        </Text>      </Pressable>      {error && (        <Text style={styles.errorText}>{error}</Text>      )}      <Text style={styles.sectionTitle}>Available devices</Text>      <ScrollView style={styles.deviceList}>        {isScanning ? (          <ActivityIndicator size="large" color="#4CAF50" />        ) : availableDevices.length > 0 ? (          availableDevices.map((device) => (            <Link               key={device.id}              href={{                pathname: "/touchpad",                params: { serverIp: device.ip }              }}              asChild            >              <Pressable style={styles.deviceItem}>                <MaterialIcons name="computer" size={24} color="#fff" style={styles.deviceIcon} />                <View>                  <Text style={styles.deviceName}>{device.name}</Text>                  <Text style={styles.deviceIp}>{device.ip}</Text>                </View>              </Pressable>            </Link>          ))        ) : (          <Text style={styles.noDevicesText}>No devices found</Text>        )}      </ScrollView>    </View>  );}const styles = StyleSheet.create({  container: {    flex: 1,    backgroundColor: '#1a1a1a',    padding: 20,  },  title: {    fontSize: 34,    fontWeight: 'bold',    color: '#ffffff',    marginBottom: 20,  },  descriptionText: {    fontSize: 16,    color: '#cccccc',    marginBottom: 40,    lineHeight: 24,  },  sectionTitle: {    fontSize: 24,    fontWeight: 'bold',    color: '#ffffff',    marginBottom: 15,  },  deviceList: {    flex: 1,  },  deviceItem: {    flexDirection: 'row',    alignItems: 'center',    padding: 16,    backgroundColor: '#2a2a2a',    borderRadius: 8,    marginBottom: 10,  },  deviceIcon: {    marginRight: 15,  },  deviceName: {    fontSize: 18,    color: '#ffffff',  },  scanButton: {    backgroundColor: '#4CAF50',    padding: 12,    borderRadius: 8,    marginBottom: 20,  },  scanButtonText: {    color: '#fff',    fontSize: 16,    fontWeight: 'bold',    textAlign: 'center',  },  errorText: {    color: '#ff4444',    fontSize: 14,    marginBottom: 20,  },  deviceIp: {    fontSize: 14,    color: '#999999',  },  noDevicesText: {    color: '#999999',    fontSize: 16,    textAlign: 'center',    marginTop: 20,  }});//touchpad.tsximport { useRouter, useLocalSearchParams } from 'expo-router';  // Instead of using navigation propimport React, { useState, useEffect, useRef } from 'react';import { View, PanResponder, Button, StyleSheet } from 'react-native';import axios from 'axios';const App = () => {    const router = useRouter(); // Use the router hook    //const [serverIp, setServerIp] = useState('192.168.1.107'); // Replace with your computer's IP    const { serverIp } = useLocalSearchParams<{ serverIp: string }>();    const [screenSize, setScreenSize] = useState({ width: 0, height: 0 });    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 }); // Tracks current mouse position    useEffect(() => {        const fetchInitialData = async () => {            try {                const screenResponse = await axios.get(`http://${serverIp}:3000/screen`);                setScreenSize(screenResponse.data);                const mouseResponse = await axios.get(`http://${serverIp}:3000/mouse/position`);                setMousePosition(mouseResponse.data);            } catch (error) {                console.error('Error fetching initial data:', error);            }        };        fetchInitialData();    }, [serverIp]);    const [isHolding, setIsHolding] = useState(false);    const lastTapTime = useRef(0);    const TAP_INTERVAL = 300; // ms between taps to count as double-tap        const [isDragging, setIsDragging] = useState(false);    const lastMouseCheck = useRef(Date.now());    const IDLE_CHECK_INTERVAL = 2000; // Check mouse position after 2s idleuseEffect(() => {    const checkMousePosition = async () => {        if (Date.now() - lastMouseCheck.current > IDLE_CHECK_INTERVAL) {            try {                const mouseResponse = await axios.get(`http://${serverIp}:3000/mouse/position`);                setMousePosition(mouseResponse.data);                lastMouseCheck.current = Date.now();            } catch (error) {                console.error('Error fetching mouse position:', error);            }        }    };    const interval = setInterval(checkMousePosition, IDLE_CHECK_INTERVAL);    return () => clearInterval(interval);}, [serverIp]);// Add this state for tracking touchesconst [touchCount, setTouchCount] = useState(0);const [lastClickTime, setLastClickTime] = useState(0);const CLICK_DELAY = 200; // Delay to check for potential double tapconst [isLeftClickHeld, setIsLeftClickHeld] = useState(false);const MOVEMENT_THRESHOLD = 1; // Increased threshold for movement detectionconst panResponder = PanResponder.create({    onStartShouldSetPanResponder: () => true,    onMoveShouldSetPanResponder: () => true,        onPanResponderGrant: (evt) => {        const touches = evt.nativeEvent.touches.length;        setTouchCount(touches);                const currentTime = Date.now();        pressStartTime.current = currentTime;        hasMoved.current = false;                if (touches === 2) {            setIsLeftClickHeld(true);            axios.post(`http://${serverIp}:3000/mouse/hold`, { button: 'left', action: 'down' });        } else if (touches === 1) {            if (currentTime - lastTapTime.current < TAP_INTERVAL) {                setLastClickTime(0);                axios.post(`http://${serverIp}:3000/mouse/hold`, { button: 'left', action: 'down' });                setIsDragging(true);            }            lastTapTime.current = currentTime;        }    },        onPanResponderMove: (event, gesture) => {        const touches = event.nativeEvent.touches.length;                // Increase threshold for movement detection        if (Math.abs(gesture.dx) > MOVEMENT_THRESHOLD || Math.abs(gesture.dy) > MOVEMENT_THRESHOLD) {            hasMoved.current = true;        }                const newX = Math.min(Math.max(0, mousePosition.x + (gesture.dx / 300) * screenSize.width), screenSize.width);        const newY = Math.min(Math.max(0, mousePosition.y + (gesture.dy / 300) * screenSize.height), screenSize.height);        setMousePosition({ x: newX, y: newY });        axios.post(`http://${serverIp}:3000/mouse/move`, { x: newX, y: newY });    },        onPanResponderRelease: () => {        const pressDuration = Date.now() - pressStartTime.current;        const currentTime = Date.now();                if (isLeftClickHeld) {            setIsLeftClickHeld(false);            axios.post(`http://${serverIp}:3000/mouse/hold`, { button: 'left', action: 'up' });        }                // Only trigger clicks if there was minimal movement        if (touchCount === 1) {            if (isDragging) {                axios.post(`http://${serverIp}:3000/mouse/hold`, { button: 'left', action: 'up' });                setIsDragging(false);            } else if (!hasMoved.current) {  // This check is now more strict due to higher threshold                if (pressDuration < 500) {                    setLastClickTime(currentTime);                    setTimeout(() => {                        if (Date.now() - lastClickTime >= TAP_INTERVAL) {                            handleClick('left');                        }                    }, CLICK_DELAY);                } else {                    handleClick('right');                }            }        }                setTouchCount(0);    },});    const pressStartTime = useRef(0);    const hasMoved = useRef(false);    const handleClick = (buttonType: 'left' | 'right') => {        axios.post(`http://${serverIp}:3000/mouse/click`, { button: buttonType });    };    return (        <View style={styles.container}>            <View style={styles.touchpad} {...panResponder.panHandlers} />            <View style={styles.buttonContainer}>                <Button title="Left Click" onPress={() => handleClick('left')} />                <Button title="Right Click" onPress={() => handleClick('right')} />            </View>        </View>    );};const styles = StyleSheet.create({    container: { flex: 1, justifyContent: 'center', alignItems: 'center' },    touchpad: {        width: 400,        height: 700,        backgroundColor: '#ddd',        borderRadius: 10,        marginBottom: 20,    },    buttonContainer: {        flexDirection: 'row',        gap: 10,    }});export default App;//useDeviceScanning.tsimport { useState, useEffect, useRef } from 'react';import NetInfo from '@react-native-community/netinfo';import axios from 'axios';interface Device {  id: string;  name: string;  ip: string;  port: number;}const useDeviceScanning = () => {  const [availableDevices, setAvailableDevices] = useState<Device[]>([]);  const [isScanning, setIsScanning] = useState(false);  const [error, setError] = useState<string | null>(null);  const wsConnections = useRef<Map<string, WebSocket>>(new Map());  const devicesMap = useRef<Map<string, Device>>(new Map());  const testConnection = async (ip: string): Promise<boolean> => {    try {      // First try HTTP connection to verify server is running      const response = await axios.get(`http://${ip}:3000/ping`, { timeout: 1000 });      return response.data === 'Server is running';    } catch {      return false;    }  };  const connectToWebSocket = (ip: string) => {    // Only create a new connection if one doesn't exist    if (wsConnections.current.has(ip)) return;    try {      const ws = new WebSocket(`ws://${ip}:3001`);      wsConnections.current.set(ip, ws);      ws.onopen = () => {        console.log(`WebSocket connected to ${ip}`);      };      ws.onmessage = (event) => {        try {          const device = JSON.parse(event.data);          const deviceId = `${device.ip}:${device.port}`;          if (!devicesMap.current.has(deviceId)) {            devicesMap.current.set(deviceId, {              id: deviceId,              name: device.name,              ip: device.ip,              port: device.port            });            setAvailableDevices(Array.from(devicesMap.current.values()));          }        } catch (e) {          console.error('Error parsing device data:', e);        }      };      ws.onerror = () => {        ws.close();        wsConnections.current.delete(ip);      };      ws.onclose = () => {        wsConnections.current.delete(ip);      };    } catch (e) {      console.log(`Failed to connect to ${ip}`);    }  };  const scanNetwork = async () => {    setIsScanning(true);    setError(null);    devicesMap.current.clear();    setAvailableDevices([]);    try {      const netInfo = await NetInfo.fetch();      if (netInfo.type !== 'wifi') {        throw new Error('Please connect to a WiFi network');      }      // Close existing connections      wsConnections.current.forEach(ws => ws.close());      wsConnections.current.clear();      // Get the subnet from WiFi details      const subnet = netInfo.details?.ipAddress?.split('.').slice(0, 3).join('.') || '192.168.1';            // Test specific IP if known      const knownIP = '192.168.1.107';      if (await testConnection(knownIP)) {        connectToWebSocket(knownIP);      }      // Scan subnet      for (let i = 1; i <= 10; i++) {        const ip = `${subnet}.${i}`;        if (await testConnection(ip)) {          connectToWebSocket(ip);        }      }    } catch (err) {      setError(err instanceof Error ? err.message : 'Failed to scan for devices');    } finally {      // Stop scanning after 5 seconds      setTimeout(() => {        setIsScanning(false);      }, 5000);    }  };  useEffect(() => {    scanNetwork();    return () => {      wsConnections.current.forEach(ws => ws.close());    };  }, []);  return {    availableDevices,    isScanning,    error,    scanNetwork  };};export default useDeviceScanning;//server.jsconst express = require('express');const robot = require('robotjs');const cors = require('cors');const WebSocket = require('ws');const os = require('os');const app = express();const port = 3000;const wsPort = 3001;// Enhanced IP detectionfunction getLocalIP() {    const interfaces = os.networkInterfaces();    const addresses = [];        console.log('Available network interfaces:');    for (const name of Object.keys(interfaces)) {        console.log(`\nInterface: ${name}`);        for (const interface of interfaces[name]) {            if (interface.family === 'IPv4') {                console.log(`  Address: ${interface.address}`);                console.log(`  Internal: ${interface.internal}`);                if (!interface.internal) {                    addresses.push(interface.address);                }            }        }    }        console.log('\nPotential server IPs:', addresses);    return addresses[0] || '127.0.0.1';}const ip = getLocalIP();console.log('\nSelected server IP:', ip);console.log('Server hostname:', os.hostname());// Create WebSocket server with error handlingconst wss = new WebSocket.Server({ port: wsPort }, () => {    console.log(`WebSocket server is running on port ${wsPort}`);});wss.on('error', (error) => {    console.error('WebSocket server error:', error);});// Handle WebSocket connections with detailed loggingwss.on('connection', (ws, req) => {    console.log(`New client connected from ${req.socket.remoteAddress}`);        // Send server info immediately upon connection    const serverInfo = JSON.stringify({        name: os.hostname(),        ip: ip,        port: port    });        console.log('Sending server info:', serverInfo);    ws.send(serverInfo);        ws.on('message', (message) => {        console.log('Received message:', message.toString());    });        ws.on('error', (error) => {        console.error('WebSocket client error:', error);    });        ws.on('close', () => {        console.log('Client disconnected');    });});// Enhanced CORS configurationapp.use(cors({    origin: '*',    methods: ['GET', 'POST'],    allowedHeaders: ['Content-Type']}));app.use(express.json());// Add request logging middlewareapp.use((req, res, next) => {    console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);    next();});// Test endpoint to verify server is runningapp.get('/ping', (req, res) => {    res.send('Server is running');});// Original endpoints with added loggingapp.post('/mouse/move', (req, res) => {    const { x, y } = req.body;    console.log(`Moving mouse to x: ${x}, y: ${y}`);    try {        robot.moveMouse(x, y);        res.send('Mouse moved!');    } catch (error) {        console.error('Error moving mouse:', error);        res.status(500).send('Failed to move mouse');    }});app.post('/mouse/click', (req, res) => {    const { button = 'left' } = req.body;    console.log(`Mouse click: ${button}`);    try {        robot.mouseClick(button);        res.send(`Mouse ${button} click executed!`);    } catch (error) {        console.error('Error clicking mouse:', error);        res.status(500).send('Failed to click mouse');    }});app.get('/screen', (req, res) => {    try {        const screenSize = robot.getScreenSize();        console.log('Screen size:', screenSize);        res.json(screenSize);    } catch (error) {        console.error('Error getting screen size:', error);        res.status(500).send('Failed to get screen size');    }});app.get('/mouse/position', (req, res) => {    try {        const mousePos = robot.getMousePos();        console.log('Mouse position:', mousePos);        res.json(mousePos);    } catch (error) {        console.error('Error getting mouse position:', error);        res.status(500).send('Failed to get mouse position');    }});app.post('/mouse/hold', (req, res) => {    const { button, action } = req.body;    console.log(`Mouse ${button} ${action}`);    try {        robot.mouseToggle(action, button);        res.send(`Mouse ${button} ${action}`);    } catch (error) {        console.error('Error toggling mouse:', error);        res.status(500).send('Failed to toggle mouse');    }});const server = app.listen(port, () => {    console.log(`\nHTTP server running at http://localhost:${port}`);    console.log(`Try accessing: http://${ip}:${port}/ping`);});server.on('error', (error) => {    console.error('HTTP server error:', error);});JSON files//app.json{  "expo": {    "name": "mobimouse",    "slug": "mobimouse",    "version": "1.0.0",    "orientation": "portrait",    "icon": "./assets/images/icon.png",    "scheme": "myapp",    "userInterfaceStyle": "automatic",    "newArchEnabled": true,    "ios": {      "supportsTablet": true    },    "android": {      "adaptiveIcon": {        "foregroundImage": "./assets/images/adaptive-icon.png",        "backgroundColor": "#ffffff"      }    },    "web": {      "bundler": "metro",      "output": "static",      "favicon": "./assets/images/favicon.png"    },    "plugins": [      "expo-router",      [        "expo-splash-screen",        {          "image": "./assets/images/splash-icon.png",          "imageWidth": 200,          "resizeMode": "contain",          "backgroundColor": "#ffffff"        }      ]    ],    "experiments": {      "typedRoutes": true    }  }}//package.json{  "name": "mobimouse",  "main": "expo-router/entry",  "version": "1.0.0",  "scripts": {    "start": "expo start",    "reset-project": "node ./scripts/reset-project.js",    "android": "expo start --android",    "ios": "expo start --ios",    "web": "expo start --web",    "test": "jest --watchAll",    "lint": "expo lint"  },  "jest": {    "preset": "jest-expo"  },  "dependencies": {    "@expo/vector-icons": "^14.0.4",    "@react-native-community/netinfo": "^11.4.1",    "@react-navigation/bottom-tabs": "^7.2.0",    "@react-navigation/native": "^7.0.14",    "@react-navigation/native-stack": "^7.2.0",    "axios": "^1.7.9",    "cors": "^2.8.5",    "expo": "~52.0.23",    "expo-blur": "~14.0.1",    "expo-constants": "~17.0.3",    "expo-font": "~13.0.2",    "expo-haptics": "~14.0.0",    "expo-linking": "~7.0.3",    "expo-network": "^7.0.5",    "expo-router": "~4.0.15",    "expo-splash-screen": "~0.29.18",    "expo-status-bar": "~2.0.0",    "expo-symbols": "~0.2.0",    "expo-system-ui": "~4.0.6",    "expo-web-browser": "~14.0.1",    "express": "^4.21.2",    "react": "18.3.1",    "react-dom": "18.3.1",    "react-native": "0.76.5",    "react-native-ble-manager": "^12.1.2",    "react-native-gesture-handler": "~2.20.2",    "react-native-reanimated": "~3.16.1",    "react-native-safe-area-context": "4.12.0",    "react-native-screens": "~4.4.0",    "react-native-udp": "^4.1.7",    "react-native-web": "~0.19.13",    "react-native-webview": "13.12.5",    "robotjs": "^0.6.0",    "ws": "^8.18.0"  },  "devDependencies": {    "@babel/core": "^7.25.2",    "@types/jest": "^29.5.12",    "@types/react": "~18.3.12",    "@types/react-test-renderer": "^18.3.0",    "jest": "^29.2.1",    "jest-expo": "~52.0.2",    "react-test-renderer": "18.3.1",    "typescript": "^5.3.3"  },  "private": true}