App Code//_layout.tsximport { Stack } from 'expo-router';export default function Layout() {  return (    <Stack      screenOptions={{        headerShown: false,  // This will hide the stack navigator header        headerStyle: {          backgroundColor: '#1a1a1a',        },        headerTintColor: '#fff',        headerTitleStyle: {          fontWeight: 'bold',        },      }}    />  );}//index.tsximport React, { useState } from 'react';import { View, Text, StyleSheet, ScrollView, ActivityIndicator, Pressable } from 'react-native';import { Link } from 'expo-router';import { MaterialIcons, Entypo } from '@expo/vector-icons';import useDeviceScanning from './hooks/useDeviceScanning';export default function Home() {  const { availableDevices, isScanning, error, scanNetwork } = useDeviceScanning();  const [menuVisible, setMenuVisible] = useState(false);  const Menu = () => (    <Pressable       style={styles.menuOverlay}       onPress={() => setMenuVisible(false)}    >      <View style={styles.menu}>        <Pressable           style={styles.menuItem}          onPress={() => {            scanNetwork();            setMenuVisible(false);          }}        >          <MaterialIcons name="refresh" size={24} color="#ffffff" />          <Text style={styles.menuItemText}>Refresh</Text>        </Pressable>      </View>    </Pressable>  );  return (    <View style={styles.container}>      {/* Header */}      <View style={styles.header}>        <Text style={styles.title}>MobiMouse Connect</Text>        <Pressable onPress={() => setMenuVisible(true)}>          <Entypo name="dots-three-vertical" size={24} color="#ffffff" />        </Pressable>      </View>      {/* Network Status Message */}      {error?.includes('WiFi') ? (        <View style={styles.networkStatus}>          <MaterialIcons name="wifi-off" size={24} color="#cccccc" />          <Text style={styles.networkStatusText}>            You're not connected to Wi-Fi network          </Text>        </View>      ) : (        <Text style={styles.descriptionText}>          Other devices running MobiMouse server in your same network will appear here.        </Text>      )}      {/* Device List */}      <Text style={styles.sectionTitle}>Available devices</Text>      <ScrollView style={styles.deviceList}>        {isScanning ? (          <ActivityIndicator size="large" color="#4CAF50" />        ) : availableDevices.length > 0 ? (          availableDevices.map((device) => (            <Link               key={device.id}              href={{                pathname: "/touchpad",                params: { serverIp: device.ip }              }}              asChild            >              <Pressable style={styles.deviceItem}>                <MaterialIcons name="computer" size={24} color="#fff" style={styles.deviceIcon} />                <View>                  <Text style={styles.deviceName}>{device.name}</Text>                  <Text style={styles.deviceIp}>{device.ip}</Text>                </View>              </Pressable>            </Link>          ))        ) : (          <Text style={styles.noDevicesText}>No devices found</Text>        )}      </ScrollView>      {/* Menu Overlay */}      {menuVisible && <Menu />}    </View>  );}const styles = StyleSheet.create({  container: {    flex: 1,    backgroundColor: '#1a1a1a',    padding: 20,  },  header: {    flexDirection: 'row',    justifyContent: 'space-between',    alignItems: 'center',    marginBottom: 20,  },  title: {    fontSize: 34,    fontWeight: 'bold',    color: '#ffffff',  },  networkStatus: {    flexDirection: 'row',    alignItems: 'center',    marginBottom: 40,  },  networkStatusText: {    fontSize: 16,    color: '#cccccc',    marginLeft: 10,  },  descriptionText: {    fontSize: 16,    color: '#cccccc',    marginBottom: 40,    lineHeight: 24,  },  sectionTitle: {    fontSize: 24,    fontWeight: 'bold',    color: '#ffffff',    marginBottom: 15,  },  deviceList: {    flex: 1,  },  deviceItem: {    flexDirection: 'row',    alignItems: 'center',    padding: 16,    backgroundColor: '#2a2a2a',    borderRadius: 8,    marginBottom: 10,  },  deviceIcon: {    marginRight: 15,  },  deviceName: {    fontSize: 18,    color: '#ffffff',  },  deviceIp: {    fontSize: 14,    color: '#999999',  },  noDevicesText: {    color: '#999999',    fontSize: 16,    textAlign: 'center',    marginTop: 20,  },  menuOverlay: {    position: 'absolute',    top: 0,    right: 0,    bottom: 0,    left: 0,    backgroundColor: 'rgba(0,0,0,0.5)',  },  menu: {    position: 'absolute',    top: 60,    right: 20,    backgroundColor: '#2a2a2a',    borderRadius: 8,    padding: 8,    minWidth: 150,  },  menuItem: {    flexDirection: 'row',    alignItems: 'center',    padding: 12,  },  menuItemText: {    color: '#ffffff',    fontSize: 16,    marginLeft: 12,  },});//touchpad.tsximport { useRouter, useLocalSearchParams } from 'expo-router';import React, { useState, useEffect, useRef } from 'react';import { View, Text, PanResponder, Pressable, StyleSheet, SafeAreaView } from 'react-native';import { Ionicons } from '@expo/vector-icons';import axios from 'axios';const Touchpad = () => {    const router = useRouter();    const { serverIp } = useLocalSearchParams<{ serverIp: string }>();    const [screenSize, setScreenSize] = useState({ width: 0, height: 0 });    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });    // Refs for gesture handling    const lastTapTime = useRef(0);    const lastClickTime = useRef(0);    const pressStartTime = useRef(0);    const hasMoved = useRef(false);    const dragStartPos = useRef({ x: 0, y: 0 });    const isDragging = useRef(false);    // Constants    const DOUBLE_TAP_DELAY = 300;    const HOLD_DURATION = 500;    const MOVEMENT_THRESHOLD = 5;    useEffect(() => {        const fetchInitialData = async () => {            try {                const screenResponse = await axios.get(`http://${serverIp}:3000/screen`);                setScreenSize(screenResponse.data);                const mouseResponse = await axios.get(`http://${serverIp}:3000/mouse/position`);                setMousePosition(mouseResponse.data);            } catch (error) {                console.error('Error fetching initial data:', error);            }        };        fetchInitialData();    }, [serverIp]);    type MouseButton = 'left' | 'right' | 'middle';    const handleMouseClick = async (button: MouseButton) => {        try {            await axios.post(`http://${serverIp}:3000/mouse/click`, { button });        } catch (error) {            console.error('Click error:', error);        }    };    const handleMouseHold = async (button: 'left' | 'right', action: 'down' | 'up') => {        try {            await axios.post(`http://${serverIp}:3000/mouse/hold`, { button, action });        } catch (error) {            console.error(`Mouse ${action} error:`, error);        }    };    const handleMouseDown = async (button: 'left' | 'right') => {        try {            await axios.post(`http://${serverIp}:3000/mouse/hold`, { button, action: 'down' });        } catch (error) {            console.error('Mouse down error:', error);        }    };    const handleMouseUp = async (button: 'left' | 'right') => {        try {            await axios.post(`http://${serverIp}:3000/mouse/hold`, { button, action: 'up' });        } catch (error) {            console.error('Mouse up error:', error);        }    };    const panResponder = PanResponder.create({        onStartShouldSetPanResponder: () => true,        onMoveShouldSetPanResponder: () => true,        onPanResponderGrant: async (evt) => {            const currentTime = Date.now();            pressStartTime.current = currentTime;            hasMoved.current = false;                        dragStartPos.current = { ...mousePosition };            if (currentTime - lastTapTime.current < DOUBLE_TAP_DELAY) {                isDragging.current = true;                await handleMouseHold('left', 'down'); // Only use left click for drag            }                        lastTapTime.current = currentTime;        },        onPanResponderMove: async (evt, gestureState) => {            // Check if movement exceeds threshold            if (Math.abs(gestureState.dx) > MOVEMENT_THRESHOLD ||                 Math.abs(gestureState.dy) > MOVEMENT_THRESHOLD) {                hasMoved.current = true;            }            // Calculate new mouse position            const sensitivity = 1.5; // Adjust this value to change mouse movement speed            const newX = Math.min(Math.max(0,                 mousePosition.x + (gestureState.dx * sensitivity)), screenSize.width);            const newY = Math.min(Math.max(0,                 mousePosition.y + (gestureState.dy * sensitivity)), screenSize.height);            setMousePosition({ x: newX, y: newY });                        try {                await axios.post(`http://${serverIp}:3000/mouse/move`, { x: newX, y: newY });            } catch (error) {                console.error('Move error:', error);            }        },        onPanResponderRelease: async (evt) => {            const pressDuration = Date.now() - pressStartTime.current;            if (isDragging.current) {                await handleMouseHold('left', 'up');                isDragging.current = false;                return;            }            if (!hasMoved.current) {                if (pressDuration < HOLD_DURATION) {                    await handleMouseClick('left');                } else {                    await handleMouseClick('right');                }            }        },        onPanResponderTerminate: async () => {            if (isDragging.current) {                await handleMouseHold('left', 'up');                isDragging.current = false;            }        },    });    const handleMiddleClick = () => {        handleMouseClick('left');    };    return (        <View style={styles.container}>            {/* Header */}            <View style={styles.header}>                <Pressable onPress={() => router.back()} style={styles.backButton}>                    <Ionicons name="chevron-back" size={24} color="#fff" />                    <Text style={styles.headerTitle}>Touch Input</Text>                </Pressable>                <Ionicons name="keypad-outline" size={24} color="#fff" />            </View>            {/* Touch area with instruction text */}            <View style={styles.touchAreaContainer}>                <Text style={styles.instructionText}>                    Move your finger on the screen to move the mouse cursor                </Text>                <View style={styles.touchpad} {...panResponder.panHandlers} />            </View>            {/* Bottom buttons */}            <View style={styles.buttonContainer}>                <Pressable                     style={styles.button}                    onPress={() => handleMouseClick('left')}                >                    <Text style={styles.buttonText}>L</Text>                </Pressable>                <Pressable                     style={[styles.button, styles.middleButton]}                    onPress={() => handleMouseClick('middle')}                >                    <Text style={styles.buttonText}>M</Text>                </Pressable>                <Pressable                     style={styles.button}                    onPress={() => handleMouseClick('right')}                >                    <Text style={styles.buttonText}>R</Text>                </Pressable>            </View>        </View>    );};const styles = StyleSheet.create({    container: {        flex: 1,        backgroundColor: '#1a1a1a',    },    header: {        flexDirection: 'row',        alignItems: 'center',        justifyContent: 'space-between',        paddingHorizontal: 16,        paddingVertical: 12,        borderBottomWidth: 1,        borderBottomColor: '#333333',        backgroundColor: '#1a1a1a',    },    backButton: {        flexDirection: 'row',        alignItems: 'center',    },    headerTitle: {        fontSize: 18,        fontWeight: '500',        marginLeft: 8,        color: '#ffffff',    },    touchAreaContainer: {        flex: 1,        justifyContent: 'center',        alignItems: 'center',        paddingHorizontal: 20,        backgroundColor: '#1a1a1a',    },    instructionText: {        fontSize: 16,        color: '#cccccc',        textAlign: 'center',        marginBottom: 20,    },    touchpad: {        width: '100%',        flex: 1,        backgroundColor: '#2a2a2a',        borderRadius: 12,        borderWidth: 1,        borderColor: '#333333',    },    buttonContainer: {        flexDirection: 'row',        justifyContent: 'center',        padding: 20,        gap: 10,        backgroundColor: '#1a1a1a',    },    button: {        flex: 1,        backgroundColor: '#2a2a2a',        borderRadius: 25,        height: 50,        justifyContent: 'center',        alignItems: 'center',        maxWidth: 120,        borderWidth: 1,        borderColor: '#333333',    },    middleButton: {        maxWidth: 50,    },    buttonText: {        fontSize: 16,        fontWeight: '500',        color: '#ffffff',    },});export default Touchpad;//useDeviceScanning.tsimport { useState, useEffect } from 'react';import NetInfo from '@react-native-community/netinfo';import * as Network from 'expo-network';import axios from 'axios';interface Device {  id: string;  name: string;  ip: string;  port: number;}const useDeviceScanning = () => {  const [availableDevices, setAvailableDevices] = useState<Device[]>([]);  const [isScanning, setIsScanning] = useState(false);  const [error, setError] = useState<string | null>(null);  const scanNetwork = async () => {    setIsScanning(true);    setError(null);    setAvailableDevices([]);    try {      const netInfo = await NetInfo.fetch();      if (netInfo.type !== 'wifi') {        throw new Error('Please connect to a WiFi network');      }      const ipAddress = await Network.getIpAddressAsync();      const subnet = ipAddress.substring(0, ipAddress.lastIndexOf('.'));            // Scan common ports on all IPs in subnet      const scanPromises = [];      for (let i = 1; i < 255; i++) {        const testIP = `${subnet}.${i}`;        scanPromises.push(          axios.get(`http://${testIP}:3000/ping`, { timeout: 1000 })            .then(() => ({              id: `${testIP}:3000`,              name: `Device at ${testIP}`,              ip: testIP,              port: 3000            }))            .catch(() => null)        );      }      const results = await Promise.all(scanPromises);      const devices = results.filter((device): device is Device => device !== null);      setAvailableDevices(devices);    } catch (err) {      setError(err instanceof Error ? err.message : 'Failed to scan network');    } finally {      setIsScanning(false);    }  };  useEffect(() => {    scanNetwork();  }, []);  return {    availableDevices,    isScanning,    error,    scanNetwork  };};export default useDeviceScanning;App JSON files//package.json{  "name": "mobimouse",  "main": "expo-router/entry",  "version": "1.0.0",  "scripts": {    "start": "expo start",    "reset-project": "node ./scripts/reset-project.js",    "android": "expo start --android",    "ios": "expo start --ios",    "web": "expo start --web",    "test": "jest --watchAll",    "lint": "expo lint"  },  "jest": {    "preset": "jest-expo"  },  "dependencies": {    "@expo/vector-icons": "^14.0.4",    "@react-native-community/netinfo": "^11.4.1",    "@react-navigation/bottom-tabs": "^7.2.0",    "@react-navigation/native": "^7.0.14",    "@react-navigation/native-stack": "^7.2.0",    "axios": "^1.7.9",    "expo": "~52.0.23",    "expo-blur": "~14.0.1",    "expo-constants": "~17.0.3",    "expo-font": "~13.0.2",    "expo-haptics": "~14.0.0",    "expo-linking": "~7.0.3",    "expo-network": "~7.0.5",    "expo-router": "~4.0.15",    "expo-splash-screen": "~0.29.18",    "expo-status-bar": "~2.0.0",    "expo-symbols": "~0.2.0",    "expo-system-ui": "~4.0.6",    "expo-web-browser": "~14.0.1",    "react": "18.3.1",    "react-dom": "18.3.1",    "react-native": "0.76.5",    "react-native-ble-manager": "^12.1.2",    "react-native-gesture-handler": "~2.20.2",    "react-native-reanimated": "~3.16.1",    "react-native-safe-area-context": "4.12.0",    "react-native-screens": "~4.4.0",    "react-native-web": "~0.19.13",    "react-native-webview": "13.12.5"  },  "devDependencies": {    "@babel/core": "^7.25.2",    "@types/jest": "^29.5.12",    "@types/react": "~18.3.12",    "@types/react-test-renderer": "^18.3.0",    "jest": "^29.2.1",    "jest-expo": "~52.0.2",    "react-test-renderer": "18.3.1",    "typescript": "^5.3.3"  },  "private": true}//app.json{  "expo": {    "name": "mobimouse",    "slug": "mobimouse",    "version": "1.0.0",    "orientation": "portrait",    "icon": "./assets/images/icon.png",    "scheme": "myapp",    "userInterfaceStyle": "automatic",    "newArchEnabled": true,    "ios": {      "supportsTablet": true    },    "android": {      "adaptiveIcon": {        "foregroundImage": "./assets/images/adaptive-icon.png",        "backgroundColor": "#ffffff"      },      "package": "com.ironsteels.mobi",      "permissions": [        "ACCESS_NETWORK_STATE",        "ACCESS_WIFI_STATE",        "INTERNET"      ]    },    "web": {      "bundler": "metro",      "output": "static",      "favicon": "./assets/images/favicon.png"    },    "plugins": [      "expo-router",      [        "expo-splash-screen",        {          "image": "./assets/images/splash-icon.png",          "imageWidth": 200,          "resizeMode": "contain",          "backgroundColor": "#ffffff"        }      ]    ],    "experiments": {      "typedRoutes": true    },    "extra": {      "router": {        "origin": false      },      "eas": {        "projectId": "def8cbf2-9da3-4942-8dd2-028a001177ae"      }    }  }}Server files//server.jsconst express = require('express');const cors = require('cors');const WebSocket = require('ws');const os = require('os');const ffi = require('ffi-napi');const ref = require('ref-napi');const StructType = require('ref-struct-napi');const app = express();const port = 3000;const wsPort = 3001;// Error handling for uncaught exceptionsprocess.on('uncaughtException', (err) => {    console.error('Uncaught Exception:', err);});process.on('unhandledRejection', (reason, promise) => {    console.error('Unhandled Rejection at:', promise, 'reason:', reason);});const POINT = StructType({    x: 'long',    y: 'long'});const MOUSEEVENTF_LEFTDOWN = 0x0002;const MOUSEEVENTF_LEFTUP = 0x0004;const MOUSEEVENTF_RIGHTDOWN = 0x0008;const MOUSEEVENTF_RIGHTUP = 0x0010;const MOUSEEVENTF_MIDDLEDOWN = 0x0020;const MOUSEEVENTF_MIDDLEUP = 0x0040;const SM_CXSCREEN = 0;const SM_CYSCREEN = 1;// Define Windows API structures with error handlinglet user32;try {    user32 = ffi.Library('user32.dll', {        'SetCursorPos': ['bool', ['int', 'int']],        'GetCursorPos': ['bool', [ref.refType(POINT)]],        'mouse_event': ['void', ['int', 'int', 'int', 'int', 'int']],        'GetSystemMetrics': ['int', ['int']]    });    if (!user32) {        throw new Error('Failed to load user32.dll');    }} catch (error) {    console.error('FFI Library Loading Error:', error);    process.exit(1);}// Keep track of active connectionsconst activeConnections = new Set();function getLocalIPs() {    try {        const interfaces = os.networkInterfaces();        const addresses = [];                for (const name of Object.keys(interfaces)) {            for (const interface of interfaces[name]) {                if (interface.family === 'IPv4' && !interface.internal) {                    addresses.push(interface.address);                }            }        }        return addresses;    } catch (error) {        console.error('Error getting local IPs:', error);        return ['localhost'];    }}const localIPs = getLocalIPs();// Mouse control functions with retry logicfunction withRetry(fn, maxRetries = 3) {    return async (...args) => {        for (let i = 0; i < maxRetries; i++) {            try {                return await fn(...args);            } catch (error) {                if (i === maxRetries - 1) throw error;                await new Promise(resolve => setTimeout(resolve, 100));            }        }    };}const moveMouse = async (x, y) => {    const result = user32.SetCursorPos(Math.floor(x), Math.floor(y));    if (!result) throw new Error('Failed to move cursor');};const getMousePosition = async () => {    const point = new POINT();    const result = user32.GetCursorPos(point.ref());    if (!result) throw new Error('Failed to get cursor position');    return { x: point.x, y: point.y };};const mouseClick = async (button = 'left') => {    if (button === 'left') {        user32.mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);        await new Promise(resolve => setTimeout(resolve, 50));        user32.mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    } else if (button === 'right') {        user32.mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);        await new Promise(resolve => setTimeout(resolve, 50));        user32.mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);    } else if (button === 'middle') {        user32.mouse_event(MOUSEEVENTF_MIDDLEDOWN, 0, 0, 0, 0);        await new Promise(resolve => setTimeout(resolve, 50));        user32.mouse_event(MOUSEEVENTF_MIDDLEUP, 0, 0, 0, 0);    }};const getScreenMetrics = () => {    const width = user32.GetSystemMetrics(SM_CXSCREEN);    const height = user32.GetSystemMetrics(SM_CYSCREEN);    return { width, height };};const mouseHold = withRetry(async (button = 'left', action = 'down') => {    if (button === 'left') {        action === 'down' ?             user32.mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0) :            user32.mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);    } else if (button === 'right') {        action === 'down' ?            user32.mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0) :            user32.mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);    } else if (button === 'middle') {        action === 'down' ?            user32.mouse_event(MOUSEEVENTF_MIDDLEDOWN, 0, 0, 0, 0) :            user32.mouse_event(MOUSEEVENTF_MIDDLEUP, 0, 0, 0, 0);    }});// Express middleware for loggingapp.use((req, res, next) => {    console.log(`${new Date().toISOString()} ${req.method} ${req.url}`);    next();});app.use(cors());app.use(express.json());// Request handlers with proper error handlingapp.post('/mouse/move', async (req, res) => {    try {        const { x, y } = req.body;        console.log(`Moving mouse to x: ${x}, y: ${y}`);        await moveMouse(x, y);        res.json({ success: true });    } catch (error) {        console.error('Error moving mouse:', error);        res.status(500).json({ error: error.message });    }});app.post('/mouse/click', async (req, res) => {    try {        const { button = 'left' } = req.body;        await mouseClick(button);        res.json({ success: true });    } catch (error) {        console.error('Error clicking mouse:', error);        res.status(500).json({ error: error.message });    }});app.post('/mouse/hold', async (req, res) => {    try {        const { button = 'left', action = 'down' } = req.body;        console.log(`Mouse ${button} button ${action}`);        await mouseHold(button, action);        res.json({ success: true });    } catch (error) {        console.error('Error with mouse hold:', error);        res.status(500).json({ error: error.message });    }});app.get('/mouse/position', async (req, res) => {    try {        const pos = await getMousePosition();        res.json(pos);    } catch (error) {        console.error('Error getting mouse position:', error);        res.status(500).json({ error: error.message });    }});app.get('/ping', (req, res) => {    res.json({ status: 'ok', connections: activeConnections.size });});app.get('/screen', (req, res) => {    try {        const SM_CXSCREEN = 0;        const SM_CYSCREEN = 1;                const width = user32.GetSystemMetrics(SM_CXSCREEN);        const height = user32.GetSystemMetrics(SM_CYSCREEN);                res.json({ width, height });    } catch (error) {        console.error('Error getting screen metrics:', error);        res.status(500).json({ error: error.message });    }});app.get('/screen', (req, res) => {    try {        const screenSize = getScreenMetrics();        res.json(screenSize);    } catch (error) {        console.error('Error getting screen metrics:', error);        res.status(500).json({ error: error.message });    }});app.get('/ping', (req, res) => {    res.header('Access-Control-Allow-Origin', '*');    res.json({       status: 'ok',      name: os.hostname(),      connections: activeConnections.size     });  });// WebSocket server with connection trackingconst wss = new WebSocket.Server({ port: wsPort });wss.on('connection', (ws) => {    try {        const id = Date.now().toString();        activeConnections.add(id);        console.log(`Client connected (${activeConnections.size} total)`);                // Add more robust error handling        ws.on('error', (error) => {            console.error('WebSocket connection error:', error);            activeConnections.delete(id);        });        // Wrap send in try-catch        try {            ws.send(JSON.stringify({                type: 'connected',                name: os.hostname(),                ip: localIPs[0],                port: port            }));        } catch (sendError) {            console.error('Failed to send connection message:', sendError);        }    } catch (setupError) {        console.error('WebSocket setup error:', setupError);    }});// Start server with error handlingconst server = app.listen(port, () => {    console.log(`Server running at http://localhost:${port}`);    console.log('Available on:');    localIPs.forEach(ip => {        console.log(`  http://${ip}:${port}`);    });}).on('error', (error) => {    console.error('Server error:', error);});// Graceful shutdownprocess.on('SIGTERM', () => {    server.close(() => {        console.log('Server shutting down');        process.exit(0);    });});Server JSON file//package.json{  "name": "mobimouse",  "version": "1.0.0",  "main": "server.js",  "bin": "server.js",  "pkg": {    "targets": [      "node16-win-x64"    ],    "assets": [      "node_modules/**/*"    ],    "outputPath": "dist"  },  "dependencies": {    "cors": "^2.8.5",    "express": "^4.17.1",    "ffi-napi": "^4.0.3",    "ref-napi": "^3.0.3",    "ref-struct-napi": "^1.1.1",    "ws": "^8.2.0"  },  "scripts": {    "start": "node server.js",    "build": "pkg ."  }}